/**
 * @copyright 2014-present, Prometheus Research, LLC
 */

import * as ReactForms from 'react-forms';
import * as React from 'react';
import * as ReactUI from '@prometheusresearch/react-ui';
import isArray from 'lodash/isArray';
import isString from 'lodash/isString';
import noop from 'lodash/noop';

import {InjectI18N} from 'rex-i18n';

import {isComplete} from './Discrepancy';
import DiscrepancyList from './DiscrepancyList';
import {fromDiscrepancies} from './schema';
import {createReactFormsMessages} from '../instrument/validate';
import FormContext from '../form/FormContext';


function makeSolution(value) {
  let {...solution} = value;

  Object.keys(solution).forEach((key) => {
    if (isArray(solution[key]) && !isString(solution[key][0])) {
      let mapped = {};
      solution[key].forEach((rec, idx) => {
        mapped[String(idx)] = rec;
      });
      solution[key] = mapped;
    }
  });

  return solution;
}


@InjectI18N
export default class Reconciler extends React.Component {

  static propTypes = {
    /**
     * The RIOS Web Form Configuration to display.
     */
    form: React.PropTypes.object.isRequired,

    /**
     * The RIOS Instrument Definition that corresponds with the form.
     */
    instrument: React.PropTypes.object.isRequired,

    /**
     * The values for the custom/external variables used by the form.
     */
    parameters: React.PropTypes.object,

    /**
     * The value discrepancies between the Entries (as generated by the
     * rex.instrument library).
     */
    discrepancies: React.PropTypes.object.isRequired,

    /**
     * Information about the Entries being reconciled.
     */
    entries: React.PropTypes.array.isRequired,

    /**
     * The function to call when the user has made changes to their selections.
     * The callback will receive an object that contains:
     * * solution: The current state of the reconciled values that have been
     *   selected by the user so far.
     */
    onChange: React.PropTypes.func,

    /**
     * The function to call when the user has completed reconciliation. The
     * callback will receive an object that contains:
     * * solution: The final reconciled values to apply as a solution to the
     *   discrepancies.
     */
    onComplete: React.PropTypes.func,

    /**
     * A collection of API URLs that are used by various widgets or
     * functionality in the form.
     */
    apiUrls: React.PropTypes.object,
  };

  static defaultProps = {
    parameters: {},
    onComplete: noop,
    onChange: noop,
    apiUrls: {},
  };

  constructor(props, context) {
    super(props, context);
    let {discrepancies, instrument, form} = props;
    let i18n = this.getI18N();
    let messages = createReactFormsMessages({i18n});
    this.state = {
      formValue: ReactForms.createValue({
        schema: fromDiscrepancies(discrepancies, instrument, form, {i18n}),
        onChange: this.onChange,
        validate: (schema, value) => {
          return ReactForms.Schema.validate(schema, value, {messages});
        },
      }),
      isComplete: false,
    };
  }

  render() {
    let {form, parameters, discrepancies, entries, apiUrls} = this.props;
    let {formValue} = this.state;
    let showComplete = !this.state.isComplete;
    return (
      <FormContext
        self={this}
        form={form}
        parameters={parameters}
        events={null}
        apiUrls={apiUrls || {}}>
        <div>
          <DiscrepancyList
            entries={entries}
            formValue={formValue}
            />
          <ReactUI.Block textAlign="center">
            {showComplete &&
              <ReactUI.SuccessButton
                disabled={!isComplete(formValue, discrepancies)}
                onClick={this.onComplete}>
                {this._('Complete Reconciliation')}
              </ReactUI.SuccessButton>
            }
          </ReactUI.Block>
        </div>
      </FormContext>
    );
  }

  componentWillReceiveProps({form, instrument, parameters, discrepancies}) {
    if (form !== this.props.form) {
      console.warn( // eslint-disable-line no-console
        '<Reconciler /> does not handle updating "form" prop'
      );
    }
    if (instrument !== this.props.instrument) {
      console.warn( // eslint-disable-line no-console
        '<Reconciler /> does not handle updating "instrument" prop'
      );
    }
    if (parameters !== this.props.parameters) {
      console.warn( // eslint-disable-line no-console
        '<Reconciler /> does not handle updating "parameters" prop'
      );
    }
    if (discrepancies !== this.props.discrepancies) {
      console.warn( // eslint-disable-line no-console
        '<Reconciler /> does not handle updating "discrepancies" prop'
      );
    }
  }

  onComplete = () => {
    this.setState({
      isComplete: true,
    }, () => {
      this.props.onComplete({
        solution: makeSolution(this.state.formValue.value),
      });
    });
  };

  onChange = (formValue) => {
    this.props.onChange({
      solution: makeSolution(formValue.value),
    });
    this.setState({formValue});
  };
}

