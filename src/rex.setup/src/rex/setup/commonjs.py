#
# Copyright (c) 2012-2014, Prometheus Research, LLC
#


import sys
import os, os.path
import shutil
import stat
import subprocess
import tempfile
import json
import email
import distutils.log, distutils.errors
import pkg_resources


def find_executable(executables, title=None):
    if not isinstance(executables, (tuple, list)):
        executables = [executables]
    # Finds the executable in $PATH; excludes wrappers generated by rex.setup.
    paths = os.environ['PATH'].split(os.pathsep)
    # if Python is installed in virtualenv we add its bin/ directory to checked
    # paths
    for executable in executables:
        if hasattr(sys, 'real_prefix'):
            paths.insert(0, os.path.join(sys.prefix, 'bin'))
        for path in paths:
            filename = os.path.join(path, executable)
            if os.path.isfile(filename):
                # Skip `node` and `npm` shims created by `setup_commonjs()`.
                with open(filename, 'rb') as stream:
                    stream.readline()
                    if 'rex.setup' in stream.readline():
                        continue
                return filename
    raise distutils.errors.DistutilsSetupError(
            "cannot find `%s` executable; %s is not installed?"
            % (executable, title or executable.title()))


def get_commonjs_environment():
    # Returns environment variables in which we execute `node` and `npm`.
    env = {}
    if hasattr(sys, 'real_prefix'):
        # If Python is installed in a virtualenv, make sure NodeJS loads and
        # installs modules within the virtualenv tree.
        env['NODE_PATH'] = os.path.join(sys.prefix, 'lib', 'node_modules')
        env['NPM_CONFIG_PREFIX'] = sys.prefix
        env['PATH'] = '%s:%s' % (
            os.path.join(sys.prefix, 'bin'),
            os.environ.get('PATH', '')
        )
    else:
        # Even if we are outside virtualenv, make sure we pick up any
        # environment customizations
        if 'NODE_PATH' in os.environ:
            env['NODE_PATH'] = os.environ['NODE_PATH']
        if 'NPM_CONFIG_PREFIX' in os.environ:
            env['NPM_CONFIG_PREFIX'] = os.environ['NPM_CONFIG_PREFIX']
    return env


def setup_commonjs():
    # Verifies that NodeJS and NPM are available.

    # Find `node` and `npm` executables.
    real_node_path = find_executable(('node', 'nodejs'), 'Node.js')
    real_npm_path = find_executable('npm', 'NPM')

    # When Python is installed in a virtualenv, add shim `node` and
    # `npm` executables to the virtualenv tree.  It is done for convenience
    # of developers working within the virtual environment, we never
    # start these executables in our code.
    env = get_commonjs_environment()
    if env:
        node_path = os.path.join(sys.prefix, 'bin', 'node')
        npm_path = os.path.join(sys.prefix, 'bin', 'npm')
        for (path, real_path) in [(node_path, real_node_path),
                                  (npm_path, real_npm_path)]:
            if os.path.exists(path):
                continue
            distutils.log.info("creating %s shim" % path)
            stream = open(path, 'w')
            stream.write('#!/bin/sh\n')
            stream.write('# Autogenerated by rex.setup.\n')
            for key, value in sorted(env.items()):
                stream.write('export {0}="{1}"\n'.format(key, value))
            stream.write('exec {} "$@"\n'.format(real_path))
            stream.close()
            mode = os.stat(path).st_mode
            os.chmod(path, stat.S_IMODE(mode|0o111))


def exe(cmd, args, cwd=None, daemon=False, env=None, quiet=False):
    # Executes the command; returns the output or, if `daemon` is set,
    # the process object.
    setup_commonjs()
    args = [cmd] + args
    _env = {}
    _env.update(os.environ)
    _env.update(get_commonjs_environment())
    if env:
        _env.update(env)
    if not quiet:
        distutils.log.info("executing %s" % " ".join(args))
    proc = subprocess.Popen(args,
            env=_env, cwd=cwd,
            stdout=subprocess.PIPE if not daemon else None)
    if daemon:
        return proc
    out, err = proc.communicate()
    if proc.wait() != 0:
        if out:
            distutils.log.info(out)
        raise distutils.errors.DistutilsSetupError(
                "failed to execute %s" % " ".join(args))
    return out


def node(args, cwd=None, daemon=False, env=None, quiet=False):
    # Executes `node args...`.
    return exe('node', args, cwd=cwd, daemon=daemon, env=env, quiet=quiet)


def npm(args, cwd=None, env=None, quiet=False):
    # Executes `npm args...`.
    args = ['--loglevel', 'error', '--color', 'false'] + args
    return exe('npm', args, cwd=cwd, env=env, quiet=quiet)


def bower(args, cwd=None, env=None, quiet=False):
    # Executes `bower args...`.
    base_args = [find_executable('bower'), '--allow-root', '--config.interactive=false']
    return node(base_args + args, cwd, env=env, quiet=quiet)


def static_filename(req):
    dist = get_distribution(req)
    if dist is None:
        raise distutils.errors.DistutilsSetupError(
            "failed to find a Python package with embedded JS package: %s" % req)
    # Skip packages without CommonJS components.
    if not dist.has_metadata('rex_static.txt'):
        return
    static = dist.get_metadata('rex_static.txt')
    if not os.path.exists(static):
        return
    return static


def package_filename(req, *filename):
    """ Return the absolute path to the JS package embedded in the Python
    package.

    If ``filename`` is provided then it will returned as absolute path to the
    filename inside the package.

    If Python package doesn't have JS package embedded then ``None`` will be
    returned.

    :param req: Name of the Python package
    :keyword filename: Optional filename inside the JS package
    """
    static = static_filename(req)
    if static is None:
        return
    if not os.path.exists(os.path.join(static, 'js', 'bower.json')):
        return
    js_filename = os.path.abspath(os.path.join(static, 'js'))
    if filename is not None:
        js_filename = os.path.join(js_filename, *filename)
        if not os.path.exists(js_filename):
            return
    return js_filename


def bower_package_metadata(req):
    """ Return contents of ``bower.json`` metadata for a JS package.

    Returns ``None`` if JS package is not a bower component.

    :param req: Name of the Python package
    :type req: str
    :return: Component metdata
    :rtype: dict
    """
    filename = package_filename(req, 'bower.json')
    if not filename:
        return
    with open(filename, 'r') as stream:
        try:
            meta = json.load(stream)
            if not isinstance(meta, dict):
                raise ValueError("an object expected")
        except ValueError, exc:
            raise distutils.errors.DistutilsSetupError(
                    "ill-formed JSON in %s: %s" % (filename, exc))
        else:
            return (filename, meta)


def validate_bower_package_metadata(req, expected_name, expected_version):
    """ Validate bower package metadata against ``expected_name`` and
    ``expected_version``.
    """
    filename, meta = bower_package_metadata(req)
    if meta.get('name') != expected_name:
        raise distutils.errors.DistutilsSetupError(
                "unexpected meta name in %s: expected %s; got %s"
                % (filename, expected_name, meta.get('name')))
    if meta.get('version') != expected_version:
        raise distutils.errors.DistutilsSetupError(
                "unexpected meta version in %s: expected %s; got %s"
                % (filename, expected_version, meta.get('version')))
    if meta.get('dependencies') and not isinstance(meta['dependencies'], dict):
        raise distutils.errors.DistutilsSetupError(
                "\"dependencies\" key should be a JSON object in %s"
                % filename)


def ensure_rex_setup_commonjs_installed():
    """ Make sure `rex-setup` NPM package that comes with rex.setup is installed.
    """
    path = node(['-p',
                 'try { require.resolve("rex-setup") } catch (e) {""}'],
                 quiet=True)
    if not path.strip():
        cwd = pkg_resources.resource_filename('rex.setup', 'commonjs')
        npm(['install', '--global'], cwd=cwd)


def install_package(req, skip_if_installed=False):
    if package_filename(req, 'package.json'):
        install_npm_package(req, skip_if_installed=skip_if_installed)
    if package_filename(req, 'bower.json'):
        install_bower_component(req, skip_if_installed=skip_if_installed)


def install_npm_package(req, skip_if_installed=False):
    distutils.log.info("installing npm package for: %s" % req)
    cwd = package_filename(req)
    npm(['install'], cwd=cwd)


def install_bower_component(req, dest=None, skip_if_installed=False):
    dist = get_distribution(req)
    src = package_filename(req)
    if src is None:
        return
    root_install = dest is None
    # We install into temp directory because:
    # 1. We want to have components in `static/js/bower_components` but executing
    #    bower in `static/js` while we install components from python deps triggers
    #    installation of the package itself (`static/js/bower.json`)
    # 2. We can maintain bower_components in a consistent state regarding
    #    failures between multiple `bower install` calls
    if root_install:
        if skip_if_installed and \
                os.path.exists(os.path.join(src, 'bower_components')):
            return
        dest = tempfile.mkdtemp('rexsetup')
    ensure_rex_setup_commonjs_installed()
    component_name = dist.key.replace('.', '-')
    validate_bower_package_metadata(req, component_name, dist.version)
    _bower_json, meta = bower_package_metadata(req)
    # Install Bower dependencies that are packaged in Python distributions.
    dependencies = set(meta.get('dependencies', {}))
    for dep_req in dist.requires():
        dep_component_name = dep_req.key.replace('.', '-')
        if dep_component_name not in dependencies:
            continue
        # Check if the dependency is already installed.
        if os.path.exists(os.path.join(dest, 'bower_components', dep_component_name)):
            continue
        install_bower_component(dep_req, dest)
    distutils.log.info("installing bower component for: %s" % req)
    # Install component into dest/bower_components
    bower(['install', src], cwd=dest)
    # Check if Python package was installed in dev mode and link bower component
    # source instead of installing it. (a simpler alternative to `bower link`)
    is_dev_install = os.path.islink(static_filename(req))
    if is_dev_install:
        installed_path = os.path.join(dest, 'bower_components', component_name)
        _rmtree_or_unlink(installed_path)
        os.symlink(src, installed_path)
    # Move bower_components from temp dir to src/bower_components
    if root_install:
        dest_bower_components = os.path.join(src, 'bower_components')
        _rmtree_or_unlink(dest_bower_components)
        shutil.move(
            os.path.join(dest, 'bower_components'),
            dest_bower_components)
        shutil.rmtree(dest)


def _rmtree_or_unlink(directory):
    if os.path.exists(directory):
        if os.path.islink(directory):
            os.unlink(directory)
        else:
            shutil.rmtree(directory)


def get_distribution(req):
    # Returns a distribution object for the given requirement string.
    if isinstance(req, pkg_resources.Distribution):
        return req
    if not isinstance(req, pkg_resources.Requirement):
        req = pkg_resources.Requirement.parse(req)
    try:
        return pkg_resources.get_distribution(req)
    except pkg_resources.DistributionNotFound:
        pass
    # Try to find the package in the pip build directory.
    try:
        import pip
    except ImportError:
        return
    build_prefix = pip.locations.build_prefix
    package_path = os.path.join(build_prefix, req.key)
    pkg_info_path = os.path.join(package_path, 'PKG-INFO')
    if not os.path.exists(pkg_info_path):
        return
    pkg_info = email.message_from_file(open(pkg_info_path))
    name = pkg_info.get('name', '-')
    version = pkg_info.get('version')
    egg_info_path = os.path.join(package_path,
                                 'pip-egg-info/%s.egg-info' % name)
    if not os.path.exists(egg_info_path):
        return
    static_path = os.path.join(package_path, 'static')
    if os.path.exists(static_path):
        rex_static_path = os.path.join(egg_info_path, 'rex_static.txt')
        with open(rex_static_path, 'w') as stream:
            stream.write(static_path)
    dist = pkg_resources.Distribution(
            package_path,
            pkg_resources.PathMetadata(package_path, egg_info_path),
            name, version)
    return dist


