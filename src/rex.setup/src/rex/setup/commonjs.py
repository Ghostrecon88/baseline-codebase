#
# Copyright (c) 2012-2014, Prometheus Research, LLC
#


import sys
import os, os.path
import shutil
import stat
import subprocess
import json
import email
import distutils.log, distutils.errors
import pkg_resources


def find_executable(executables, title=None):
    if not isinstance(executables, (tuple, list)):
        executables = [executables]
    # Finds the executable in $PATH; excludes wrappers generated by rex.setup.
    paths = os.environ['PATH'].split(os.pathsep)
    # if Python is installed in virtualenv we add its bin/ directory to checked
    # paths
    for executable in executables:
        if hasattr(sys, 'real_prefix'):
            paths.insert(0, os.path.join(sys.prefix, 'bin'))
        for path in paths:
            filename = os.path.join(path, executable)
            if os.path.isfile(filename):
                # Skip `node` and `npm` shims created by `setup_commonjs()`.
                with open(filename, 'rb') as stream:
                    stream.readline()
                    if 'rex.setup' in stream.readline():
                        continue
                return filename
    raise distutils.errors.DistutilsSetupError(
            "cannot find `%s` executable; %s is not installed?"
            % (executable, title or executable.title()))


def get_commonjs_environment():
    # Returns environment variables in which we execute `node` and `npm`.
    env = {}
    if hasattr(sys, 'real_prefix'):
        # If Python is installed in a virtualenv, make sure NodeJS loads and
        # installs modules within the virtualenv tree.
        env['NODE_PATH'] = os.path.join(sys.prefix, 'lib', 'node_modules')
        env['NPM_CONFIG_PREFIX'] = sys.prefix
        env['PATH'] = '%s:%s' % (
            os.path.join(sys.prefix, 'bin'),
            os.environ.get('PATH', '')
        )
    else:
        # Even if we are outside virtualenv, make sure we pick up any
        # environment customizations
        if 'NODE_PATH' in os.environ:
            env['NODE_PATH'] = os.environ['NODE_PATH']
        if 'NPM_CONFIG_PREFIX' in os.environ:
            env['NPM_CONFIG_PREFIX'] = os.environ['NPM_CONFIG_PREFIX']
    return env


def setup_commonjs():
    # Verifies that NodeJS and NPM are available.

    # Find `node` and `npm` executables.
    real_node_path = find_executable(('node', 'nodejs'), 'Node.js')
    real_npm_path = find_executable('npm', 'NPM')

    # When Python is installed in a virtualenv, add shim `node` and
    # `npm` executables to the virtualenv tree.  It is done for convenience
    # of developers working within the virtual environment, we never
    # start these executables in our code.
    env = get_commonjs_environment()
    if env:
        node_path = os.path.join(sys.prefix, 'bin', 'node')
        npm_path = os.path.join(sys.prefix, 'bin', 'npm')
        for (path, real_path) in [(node_path, real_node_path),
                                  (npm_path, real_npm_path)]:
            if os.path.exists(path):
                continue
            distutils.log.info("creating %s shim" % path)
            stream = open(path, 'w')
            stream.write('#!/bin/sh\n')
            stream.write('# Autogenerated by rex.setup.\n')
            for key, value in sorted(env.items()):
                stream.write('export {0}="{1}"\n'.format(key, value))
            stream.write('exec {} "$@"\n'.format(real_path))
            stream.close()
            mode = os.stat(path).st_mode
            os.chmod(path, stat.S_IMODE(mode|0o111))


def exe(cmd, args, cwd=None, daemon=False, env=None):
    # Executes the command; returns the output or, if `daemon` is set,
    # the process object.
    setup_commonjs()
    args = [cmd] + args
    _env = {}
    _env.update(os.environ)
    _env.update(get_commonjs_environment())
    if env:
        _env.update(env)
    distutils.log.info("executing %s" % " ".join(args))
    proc = subprocess.Popen(args,
            env=_env, cwd=cwd,
            stdout=subprocess.PIPE if not daemon else None)
    if daemon:
        return proc
    out, err = proc.communicate()
    if proc.wait() != 0:
        if out:
            distutils.log.info(out)
        raise distutils.errors.DistutilsSetupError(
                "failed to execute %s" % " ".join(args))
    return out


def node(args, cwd=None, daemon=False, env=None):
    # Executes `node args...`.
    return exe('node', args, cwd=cwd, daemon=daemon, env=env)


def npm(args, cwd=None, env=None):
    # Executes `npm args...`.
    args = ['--quiet', '--color', 'false'] + args
    return exe('npm', args, cwd=cwd, env=env)


def bower(args, cwd=None, env=None):
    # Executes `bower args...`.
    base_args = [find_executable('bower'), '--allow-root', '--config.interactive=false']
    return node(base_args + args, cwd, env=env)


def install_bower_components(req):
    # Resolve a requirement string.
    dist = get_distribution(req)
    if dist is None:
        raise distutils.errors.DistutilsSetupError(
                "failed to find package with Bower component: %s" % req)
    # Skip packages without CommonJS components.
    if not dist.has_metadata('rex_static.txt'):
        return
    static = dist.get_metadata('rex_static.txt')
    if not os.path.exists(static):
        return
    if not os.path.exists(os.path.join(static, 'js', 'bower.json')):
        return
    # Make sure `rex-setup` NPM package that comes with rex.setup is installed.
    path = node(['-p',
                 'try { require.resolve("rex-setup") } catch (e) {""}'])
    if not path.strip():
        cwd = pkg_resources.resource_filename('rex.setup', 'commonjs')
        npm(['install', '--global'], cwd=cwd)
    # Validate the component descriptor.
    component_name = dist.key.replace('.', '-')
    js = os.path.abspath(os.path.join(static, 'js'))
    bower_json = os.path.join(js, 'bower.json')
    with open(bower_json) as stream:
        try:
            package = json.load(stream)
            if not isinstance(package, dict):
                raise ValueError("an object expected")
        except ValueError, exc:
            raise distutils.errors.DistutilsSetupError(
                    "ill-formed JSON in %s: %s" % (bower_json, exc))
    if package.get('name') != component_name:
        raise distutils.errors.DistutilsSetupError(
                "unexpected package name in %s: expected %s; got %s"
                % (bower_json, component_name, package.get('name')))
    if package.get('version') != dist.version:
        raise distutils.errors.DistutilsSetupError(
                "unexpected package version in %s: expected %s; got %s"
                % (bower_json, dist.version, package.get('version')))
    # Install Bower dependencies that are packaged in Python distributions.
    if isinstance(package.get('dependencies'), dict):
        dependencies = set(package['dependencies'])
        for req in dist.requires():
            dependency_name = req.key.replace('.', '-')
            if dependency_name not in dependencies:
                continue
            # Check if the dependency is already installed.
            path = os.path.join(
                    sys.prefix, 'lib', 'bower_components', dependency_name)
            if os.path.exists(path):
                continue
            install_bower_components(req)
    # Install the component into `$PREFIX/lib/bower_components`.
    distutils.log.info("installing bower component: %s" % component_name)
    cwd = os.path.join(sys.prefix, 'lib')
    # If the Python package has been installed with `python setup.py develop`,
    # install its Bower component with `bower link`, otherwise, use
    # `bower install`.
    if os.path.islink(static):
        # `bower link` is broken, we install first and then link manually.
        bower(['install', js], cwd=cwd)
        installed_path = bower_component_filename(component_name)
        if os.path.islink(installed_path):
            os.unlink(installed_path)
        else:
            shutil.rmtree(installed_path)
        os.symlink(js, installed_path)
    else:
        bower(['install', js], cwd=cwd)


def bower_component_filename(component_name, filename=None):
    path = os.path.join(
            sys.prefix, 'lib', 'bower_components', component_name)
    if not os.path.exists(path):
        raise distutils.errors.DistutilsSetupError(
                "bower component '%s' is not installed" % component_name)
    if filename is None:
        return path
    path = os.path.join(path, filename)
    if not os.path.exists(path):
        return None
    return path


def bower_component_metadata(component_name):
    """ Return contents of ``bower.json`` metadata for a component.

    :param component_name: Name of the installed bower component
    :type component_name: str
    :return: Component metdata
    :rtype: dict
    """
    bower_json = bower_component_filename(component_name, 'bower.json')
    if bower_json:
        with open(bower_json, 'r') as f:
            return json.load(f)


def get_distribution(req):
    # Returns a distribution object for the given requirement string.
    if isinstance(req, pkg_resources.Distribution):
        return req
    if not isinstance(req, pkg_resources.Requirement):
        req = pkg_resources.Requirement.parse(req)
    try:
        return pkg_resources.get_distribution(req)
    except pkg_resources.DistributionNotFound:
        pass
    # Try to find the package in the pip build directory.
    try:
        import pip
    except ImportError:
        return
    build_prefix = pip.locations.build_prefix
    package_path = os.path.join(build_prefix, req.key)
    pkg_info_path = os.path.join(package_path, 'PKG-INFO')
    if not os.path.exists(pkg_info_path):
        return
    pkg_info = email.message_from_file(open(pkg_info_path))
    name = pkg_info.get('name', '-')
    version = pkg_info.get('version')
    egg_info_path = os.path.join(package_path,
                                 'pip-egg-info/%s.egg-info' % name)
    if not os.path.exists(egg_info_path):
        return
    static_path = os.path.join(package_path, 'static')
    if os.path.exists(static_path):
        rex_static_path = os.path.join(egg_info_path, 'rex_static.txt')
        with open(rex_static_path, 'w') as stream:
            stream.write(static_path)
    dist = pkg_resources.Distribution(
            package_path,
            pkg_resources.PathMetadata(package_path, egg_info_path),
            name, version)
    return dist


