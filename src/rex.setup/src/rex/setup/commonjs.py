#
# Copyright (c) 2012-2014, Prometheus Research, LLC
#


import sys
import os, os.path
import shutil
import stat
import subprocess
import json
import distutils.log, distutils.errors
import pkg_resources


def find_executable(executable, title=None):
    # Finds the executable in $PATH; excludes wrappers generated by rex.setup.
    paths = os.environ['PATH'].split(os.pathsep)
    # if Python is installed in virtualenv we add its bin/ directory to checked
    # paths
    if hasattr(sys, 'real_prefix'):
        paths.insert(0, os.path.join(sys.prefix, 'bin'))
    for path in paths:
        filename = os.path.join(path, executable)
        if os.path.isfile(filename):
            # Skip `node` and `npm` shims created by `setup_commonjs()`.
            with open(filename, 'rb') as stream:
                stream.readline()
                if 'rex.setup' in stream.readline():
                    continue
            return filename
    raise distutils.errors.DistutilsSetupError(
            "cannot find `%s` executable; %s is not installed?"
            % (executable, title or executable.title()))


def get_commonjs_environment():
    # Returns environment variables in which we execute `node` and `npm`.
    env = {}
    # If Python is installed in a virtualenv, make sure NodeJS loads and
    # installs modules within the virtualenv tree.
    if hasattr(sys, 'real_prefix'):
        env['NODE_PATH'] = os.path.join(sys.prefix, 'lib', 'node_modules')
        env['NPM_CONFIG_PREFIX'] = sys.prefix
        env['PATH'] = '%s:%s' % (
            os.path.join(sys.prefix, 'bin'),
            os.environ.get('PATH', '')
        )
    return env


def setup_commonjs():
    # Verifies that NodeJS and NPM are available.

    # Find `node` and `npm` executables.
    real_node_path = find_executable('node', 'Node.js')
    real_npm_path = find_executable('npm', 'NPM')

    # When Python is installed in a virtualenv, add shim `node` and
    # `npm` executables to the virtualenv tree.  It is done for convenience
    # of developers working within the virtual environment, we never
    # start these executables in our code.
    env = get_commonjs_environment()
    if env:
        node_path = os.path.join(sys.prefix, 'bin', 'node')
        npm_path = os.path.join(sys.prefix, 'bin', 'npm')
        for (path, real_path) in [(node_path, real_node_path),
                                  (npm_path, real_npm_path)]:
            if os.path.exists(path):
                continue
            distutils.log.info("creating %s shim" % path)
            stream = open(path, 'w')
            stream.write('#!/bin/sh\n')
            stream.write('# Autogenerated by rex.setup.\n')
            for key, value in sorted(env.items()):
                stream.write('export {0}="{1}"\n'.format(key, value))
            stream.write('exec {} "$@"\n'.format(real_path))
            stream.close()
            mode = os.stat(path).st_mode
            os.chmod(path, stat.S_IMODE(mode|0o111))


def exe(cmd, args, cwd=None, daemon=False):
    # Executes the command; returns the output or, if `daemon` is set,
    # the process object.
    setup_commonjs()
    args = [cmd] + args
    env = {}
    env.update(os.environ)
    env.update(get_commonjs_environment())
    distutils.log.info("executing %s" % " ".join(args))
    proc = subprocess.Popen(args,
            env=env, cwd=cwd,
            stdout=subprocess.PIPE if not daemon else None)
    if daemon:
        return proc
    out, err = proc.communicate()
    if proc.wait() != 0:
        if out:
            distutils.log.info(out)
        raise distutils.errors.DistutilsSetupError(
                "failed to execute %s" % " ".join(args))
    return out


def node(args, cwd=None, daemon=False):
    # Executes `node args...`.
    return exe('node', args, cwd=cwd, daemon=daemon)


def npm(args, cwd=None):
    # Executes `npm args...`.
    args = ['--quiet', '--color', 'false'] + args
    return exe('npm', args, cwd=cwd)


def bower(args, cwd=None):
    # Executes `bower args...`.
    args = [find_executable('bower'), '--config.interactive=false'] + args
    return node(args, cwd)


def install_bower_components(dist, seen=None):
    top = (seen is None)
    # First, install the `rex-setup` NPM package that comes with rex.setup.
    if top:
        path = node(['-p',
                     'try { require.resolve("rex-setup") } catch (e) {""}'])
        if not path.strip():
            cwd = pkg_resources.resource_filename('rex.setup', 'commonjs')
            npm(['install', '--global'], cwd=cwd)
    # Installs the Bower package from the given Python package and
    # its dependencies.
    if not isinstance(dist, pkg_resources.Distribution):
        try:
            dist = pkg_resources.get_distribution(dist)
        except pkg_resources.DistributionNotFound:
            # We can only hope that this dependency doesn't contain required
            # bower components.
            distutils.log.warn("install bower components:"
                               " ignoring unavailable dependency %s" % dist)
            return
    if seen is None:
        seen = set()
    if dist.key in seen:
        return
    for req in dist.requires():
        install_bower_components(req, seen)
    if not dist.has_metadata('rex_static.txt'):
        return
    static = dist.get_metadata('rex_static.txt')
    if not os.path.exists(static):
        return
    if not os.path.exists(os.path.join(static, 'js', 'bower.json')):
        return
    component_name = dist.key.replace('.', '-')
    # Check if the package is already installed and we are not specifically
    # asked to reinstall it.
    if not top:
        path = os.path.join(
                sys.prefix, 'lib', 'bower_components', component_name)
        if os.path.exists(path):
            return
    # Validate the component.
    js = os.path.abspath(os.path.join(static, 'js'))
    bower_json = os.path.join(js, 'bower.json')
    with open(bower_json) as stream:
        try:
            package = json.load(stream)
            if not isinstance(package, dict):
                raise ValueError("an object expected")
        except ValueError, exc:
            raise distutils.errors.DistutilsSetupError(
                    "ill-formed JSON in %s: %s" % (bower_json, exc))
    if package.get('name') != component_name:
        raise distutils.errors.DistutilsSetupError(
                "unexpected package name in %s: expected %s; got %s"
                % (bower_json, component_name, package.get('name')))
    if package.get('version') != dist.version:
        raise distutils.errors.DistutilsSetupError(
                "unexpected package version in %s: expected %s; got %s"
                % (bower_json, dist.version, package.get('version')))
    # If we are inside virtualenv install into $venv/lib/bower_components
    # otherwise do a local install
    cwd = os.path.join(sys.prefix, 'lib')
    # If the Python package has been installed with `python setup.py develop`,
    # install its CommonJS package with `bower link`, otherwise, use
    # `bower install`.
    if os.path.islink(static):
        # bower link is broken, we install first and then link manually
        bower(['install', js], cwd=cwd)
        installed_path = bower_component_filename(component_name)
        if os.path.islink(installed_path):
            os.unlink(installed_path)
        else:
            shutil.rmtree(installed_path)
        os.symlink(js, installed_path)
    else:
        bower(['install', js], cwd=cwd)


def bower_component_filename(component_name, filename=None):
    path = os.path.join(
            sys.prefix, 'lib', 'bower_components', component_name)
    if not os.path.exists(path):
        raise distutils.errors.DistutilsSetupError(
                "bower component '%s' is not installed" % component_name)
    if filename is None:
        return path
    path = os.path.join(path, filename)
    if not os.path.exists(path):
        return None
    return path

def bower_component_metadata(component_name):
    """ Return contents of ``bower.json`` metadata for a component.

    :param component_name: Name of the installed bower component
    :type component_name: str
    :return: Component metdata
    :rtype: dict
    """
    bower_json = bower_component_filename(component_name, 'bower.json')
    if bower_json:
        with open(bower_json, 'r') as f:
            return json.load(f)

