#
# Copyright (c) 2013, Prometheus Research, LLC
#


from .context import get_rex
import threading
import functools
import inspect
import textwrap


class Cache(dict):
    # Application cache.

    __slots__ = ('_lock',)

    def __init__(self):
        self._lock = threading.RLock()

    def set_default_cb(self, key, callback, *args):
        # Get the cached value associated with the key; call `callback()` to
        # get the value for a new key.
        with self._lock:
            if key not in self:     # might have been set in another thread
                self[key] = callback(*args)
        return self[key]


def cached(fn):
    """
    Decorates the function to cache its return values.

    For a fixed set of arguments, on the first call, saves the return value
    in the cache of the current active application.  On subsequent calls,
    returns the cached value without reevaluating the function.
    """
    spec = inspect.getargspec(fn)
    assert (spec.keywords is None and
            spec.defaults is None and
            not any(arg.startswith('_') for arg in spec.args)), \
                    "cached function may only have positional arguments" \
                    " with no default values: %s" % repr(spec)
    # For each wrapped function, compile a custom wrapper to get nice tracebacks
    # and correct argument names in autogenerated documentation.
    name = 'cached_%s' % fn.__name__
    params = spec.args[:]
    key = spec.args[:]
    if spec.varargs is not None:
        params.append('*'+spec.varargs)
        key.append(spec.varargs)
    lineno = cached.__code__.co_firstlineno + 23    # from `def` to `source`
    source = "\n"*lineno + textwrap.dedent("""\
        def {name}({params}):
            _cache = _get_rex().cache
            _key = (_fn, {key})
            try:
                return _cache[_key]
            except KeyError:
                return _cache.set_default_cb(_key, _fn, {params})
    """).format(name=name, params=", ".join(params), key=", ".join(key))
    filename = cached.__code__.co_filename
    code = compile(source, filename, 'exec')
    context = {
            '_fn': fn,
            '_get_rex': get_rex,
    }
    exec code in context
    wrapper = context.pop(name)
    functools.update_wrapper(wrapper, fn)
    return wrapper


