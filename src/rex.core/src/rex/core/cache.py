#
# Copyright (c) 2013-2014, Prometheus Research, LLC
#


from .context import get_rex
import threading
import functools
import inspect
import textwrap
import os


class Cache(dict):
    # Application cache.

    __slots__ = ('_lock',)

    def __init__(self):
        self._lock = threading.RLock()

    def set_default_cb(self, key, callback, *args):
        # Get the cached value associated with the key; call `callback()` to
        # get the value for a new key.
        with self._lock:
            if key not in self:     # might have been set in another thread
                self[key] = callback(*args)
        return self[key]


class OpenSpy(object):
    # An utility for loading data from a file and caching the result.  Rebuilds
    # the result whenever any of the source files changes.
    # NOTE: not resistant to race conditions -- use only to enable development
    # without restarting the server.

    # Global dictionary that maps file names to their stats.
    stats = {}
    stats_version = 1
    stats_lock = threading.RLock()

    def __init__(self, callback, *args):
        # Function that generates the result.  Must have a parameter called
        # `open`.
        self.callback = callback
        # Arguments to the function.
        self.args = args
        # Cached data.
        self.result = None
        # The version of the data.
        self.version = 0

    def open(self, path):
        # Opens the file; saves its stats.
        stream = open(path)
        path = os.path.abspath(path)
        if path not in OpenSpy.stats:
            OpenSpy.stats[path] = os.fstat(stream.fileno())
        return stream

    def __call__(self):
        with OpenSpy.stats_lock:
            # Check if we can use the cached result.
            if self.version > 0:
                stats = {}
                for path in OpenSpy.stats.keys():
                    try:
                        stats[path] = os.stat(path)
                    except OSError:
                        pass
                if stats == OpenSpy.stats:
                    if self.version == OpenSpy.stats_version:
                        return self.result
                else:
                    OpenSpy.stats = stats
                    OpenSpy.stats_version += 1
            # If not, generate and cache the result.
            self.result = self.callback(*self.args, open=self.open)
            self.version = OpenSpy.stats_version
            return self.result


def cached(fn):
    """
    Decorates the function to cache its return values.

    For a fixed set of arguments, on the first call, saves the return value
    in the cache of the current active application.  On subsequent calls,
    returns the cached value without reevaluating the function.
    """
    spec = inspect.getargspec(fn)
    assert (spec.keywords is None and
            not any(arg.startswith('_') for arg in spec.args)), \
                    "cached function may only have positional arguments: %s" \
                    % repr(spec)
    # For each wrapped function, compile a custom wrapper to get nice tracebacks
    # and correct argument names in autogenerated documentation.
    name = 'cached_%s' % fn.__name__
    params = spec.args[:]
    if spec.defaults:
        k = len(spec.defaults)
        signature = params[:-k] + \
                    ["%s=%r" % pair for pair in zip(params[-k:], spec.defaults)]
    else:
        signature = params[:]
    key = spec.args[:]
    if spec.varargs is not None:
        params.append('*'+spec.varargs)
        signature.append('*'+spec.varargs)
        key.append(spec.varargs)
    lineno = cached.__code__.co_firstlineno + 30    # from `def` to `source`
    source = "\n"*lineno + textwrap.dedent("""\
        def {name}({signature}):
            _cache = _get_rex().cache
            _key = (_fn, {key})
            try:
                return _cache[_key]
            except KeyError:
                return _cache.set_default_cb(_key, _fn, {params})
    """).format(name=name, signature=", ".join(signature),
                params=", ".join(params), key=", ".join(key))
    filename = cached.__code__.co_filename
    code = compile(source, filename, 'exec')
    context = {
            '_fn': fn,
            '_get_rex': get_rex,
    }
    exec code in context
    wrapper = context.pop(name)
    functools.update_wrapper(wrapper, fn)
    return wrapper


def autoreload(fn):
    """
    Decorates the function to cache its return value.  The cached value is
    re-evaluated if any of the files opened by the function change.

    The function must have only positional arguments with the last argument
    being ``open=open``.
    """
    spec = inspect.getargspec(fn)
    assert (spec.args[-1:] == ['open'] and
            spec.defaults == (open,) and
            spec.keywords is None and
            spec.varargs is None and
            not any(arg.startswith('_') for arg in spec.args)), \
                    "auto-reloading function may only have positional arguments" \
                    " with last argument being open=open: %s" % repr(spec)
    # For each wrapped function, compile a custom wrapper to get nice tracebacks
    # and correct argument names in autogenerated documentation.
    name = 'autoreload_%s' % fn.__name__
    params = spec.args[:-1]
    lineno = autoreload.__code__.co_firstlineno + 21    # from `def` to `source`
    source = "\n"*lineno + textwrap.dedent("""\
        def {name}({params}):
            _cache = _get_rex().cache
            _key = (_fn, {params})
            try:
                _spy = _cache[_key]
            except KeyError:
                _spy = _cache.set_default_cb(_key, _OpenSpy, _fn, {params})
            return _spy()
    """).format(name=name, params=", ".join(params))
    filename = cached.__code__.co_filename
    code = compile(source, filename, 'exec')
    context = {
            '_fn': fn,
            '_get_rex': get_rex,
            '_OpenSpy': OpenSpy,
    }
    exec code in context
    wrapper = context.pop(name)
    functools.update_wrapper(wrapper, fn)
    return wrapper


