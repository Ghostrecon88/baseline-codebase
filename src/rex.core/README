***************************************************
  REX.CORE -- Core components of the Rex platform
***************************************************

.. contents:: Table of Contents


Overview
========

This package provides core components of the Rex platform:

* initialization;
* extension mechanism;
* configuration management;
* various low-level utilities.

This package is a part of the Rex platform for medical research data
management.  It is created by Prometheus Research, LLC and released under
AGPLv3 license.

Constructing applications
-------------------------

Use ``Rex`` constructor to create a new Rex application.  For example::

    >>> from rex.core import Rex

    >>> demo = Rex('rex.core_demo',
    ...            demo_folder='./demo')

This code creates a Rex application from ``rex.core_demo`` package with a
configuration parameter ``demo_folder`` set to ``'./demo'``.

Rex applications are assembled from reusable components called *packages*.
Packages that form the application are passed as positional arguments to the
``Rex`` constructor.  Application configuration is passed as keyword arguments
of the constructor.

Most API calls require you to activate the application first.  Use ``with``
statement on the application object to activate it::

    >>> from rex.core import get_rex

    >>> with demo:
    ...     print get_rex()     # get the current active application,
    ...                         # which is `demo`
    Rex('rex.core_demo', demo_folder='./demo')

The application is activated before the ``with`` block is executed and
deactivated after the block is complete.  In this example, function
``get_rex()`` returns the current active Rex application, which gives you
the same application object.

You can also use methods ``on()`` and ``off()`` for the same effect::

    >>> demo.on()
    >>> get_rex()
    Rex('rex.core_demo', demo_folder='./demo')
    >>> demo.off()

It is an error to call an API that expects an active application when no
application is activated::

    >>> get_rex()
    Traceback (most recent call last):
      ...
    AssertionError: no active Rex application

Application components
----------------------

In Rex platform, a *package* is a Python package distribution that may contain:

* Python code;
* associated static files;
* documentation;
* ``setup.py`` script.

Packages may depend on each other.  If a package is included as a part of a Rex
application, all its dependencies are also included.  Package dependencies are
determined from ``install_requires`` parameter of ``setup.py`` script.

Use function ``get_packages()`` to get the collection of packages included to
the current active application::

    >>> from rex.core import get_packages

    >>> with demo:
    ...     packages = get_packages()

You can iterate over all the packages or find a package by name::

    >>> for package in packages:
    ...     print package.name
    rex.core_demo
    rex.core

    >>> demo_package = packages['rex.core_demo']
    >>> demo_package.name
    'rex.core_demo'

Package objects provide API for reading static files included with the package.
For example, to read file ``www/index.html`` from ``static`` directory of
``rex.core_demo`` package, use::

    >>> index_file = demo_package.open('www/index.html')
    >>> index_data = index_file.read()
    >>> index_file.close()

Both absolute and relative paths are accepted; both are interpreted relative to
the ``static`` directory of the package.

Package collection provides similar API for reading static files, but to use
it, you must include the package name with the path::

    >>> index_file = packages.open('rex.core_demo:/www/index.html')

Application configuration
-------------------------

Use function ``get_settings()`` to access configuration of the current active
application::

    >>> from rex.core import get_settings

    >>> with demo:
    ...     settings = get_settings()

    >>> settings.demo_folder
    './demo'

Application configuration is generated from parameters passed to the ``Rex``
constructor as well as predefined setting values provided by packages.  The set
of available settings is determined by the set of included packages.

Creating a package
------------------

To develop a new package, start with the following layout::

    rex.<name>/
        README
        LICENSE
        setup.py
        src/
            rex/
                __init__.py
                <name>/
                    __init__.py
                    [...]
        static/
            www/
                [...]
            settings.yaml
            [...]

``README``
    Overview of the package, as well as reference of the public API exported by
    the package.

``LICENSE``
    Copy of the RexDB license.

``setup.py``
    This is a standard Distutils setup file.  It should follow the template::

        from setuptools import setup, find_packages

        setup(
            name='rex.<name>',
            version = "<version>",
            description="<description>",
            long_description=open('README', 'r').read(),
            author="Prometheus Research, LLC",
            license="AGPLv3",
            url="http://bitbucket.org/prometheus/rex.<name>",
            package_dir={'': 'src'},
            packages=find_packages('src'),
            namespace_packages=['rex'],
            entry_points={},
            setup_requres=['rex.setup'],
            install_requires=[
                <...>
            ],
            rex_init='rex.<name>',
            rex_static='static',
        )

    Use parameter ``install_requires`` to indicate package dependencies.

    To support Rex extension and distribution mechanisms, we provide two
    additional setup parameters: ``rex_static`` and ``rex_init``.  To enable
    these parameters, add a setup dependency on ``rex.setup`` package::

        setup_requres=['rex.setup'],

    You don't need this line if you don't need to define any of these
    parameters.

    ``rex_static``
        This parameter specifies the directory which contains static files to
        be distributed with the package.  By convention, we call it ``static``.
        Standard distutils commands ``install``, ``develop`` and ``sdist`` are
        extended to support this parameter.  On installation, static files are
        copied to ``<base>/share/rex/<package>``.

    ``rex_init``
        This parameter refers to the module to be executed when the application
        is initialized.  Use it for packages that define any extensions such as
        settings definitions or HTTP commands.

``src/rex/__init__.py``
    This file must declare a namespace package::

        __import__('pkg_resources').declare_namespace(__name__)

``src/rex/<name>/__init__.py``
    This file must export all public classes and functions implemented by the
    package.

``static/``
    This directory contains all static files to be distributed with the
    package.

``static/www/``
    This directory contains files accessible via HTTP.

``static/settings.yaml``
    This file provides default values for any configuration parameters.  Use it
    to configure dependent packages.

Declaring settings
------------------

To declare a setting, make a subclass of ``Setting`` class and define the
``name`` parameter.  For example, this is how setting ``demo_folder`` is
defined in ``rex.core_demo`` package::

    from rex.core import Setting, DirectoryVal

    class DemoFolderSetting(Setting):
        """Directory with demo data."""

        name = 'demo_folder'
        validate = DirectoryVal()

Setting properties are inferred from the class definition as follows:

*Name*
    Setting name is specified by the ``name`` attribute.

*Description*
    Setting description is extracted from the class docstring.

*Validation*
    To validate setting values, define method ``validate(value)`` that takes a
    raw setting value.  If the raw value is valid, it should be normalized and
    returned; otherwise, an exception should be raised.

    ``rex.core`` module provides a number of predefined validators.

*Default value*
    Define class attribute ``default`` or method ``default()`` to provide a
    default value for the setting.  If ``default`` is not specified, the
    setting is mandatory.

In order for the setting declaration to take effect, it must be loaded when the
application is initialized.  Use ``rex_init`` parameter in ``setup.py`` to
indicate the module to load.

Extension mechanism
-------------------

Rex extension mechanism allows packages to

* declare *interfaces* that provide various services;
* define *implementations* for interfaces;
* find implementations for the given interface.

To declare an interface, make a subclass of ``Extension``.  For example,
this is how ``rex.core_demo`` declares ``Command`` interface::

    from rex.core import Extension, cached

    class Command(Extension):
        """Interface for named commands."""

        name = None

        @classmethod
        def sanitize(cls):
            assert cls.name is None or isinstance(cls.name, str)

        @classmethod
        def enabled(cls):
            return (cls.name is not None)

        @classmethod
        @cached
        def by_name(cls, name):
            command_types = [command_type for command_type in cls.all()
                                          if command_type.name == name]
            assert len(command_types) >= 1, \
                    "command not found: %s" % name
            assert len(command_types) <= 1, \
                    "duplicate command: %s" % name
            return command_types[0]

        def __init__(self):
            pass

        def __call__(self):
            raise NotImplementedError("%s.__call__()"
                                      % self.__class__.__name__)

On the ``Command`` interface, we declared several methods and attributes:

``sanitize(cls)``
    This method is called when a subclass of the interface is created.  It
    allows you to perform sanity checks on the implementation definition.

``enabled(cls)``
    This method is called on every subclass of the interface.  It allows you to
    distinguish between abstract subclasses and concrete implementations.

``name``
    We expect each command to have a unique name.

``by_name(cls, name)``
    This method returns an implementation of a command by name.

To declare an implementation, make a subclass of the interface class::

    class HelloCommand(Command):
        """Greets the World!"""

        name = 'hello'

        def __call__(self):
            return "Hello, World!"

To get a list of all commands defined in the current active application, use::

    >>> from rex.core_demo import Command

    >>> with demo:
    ...     command_types = Command.all()

To find a command by name, use::

    >>> with demo:
    ...    command_type = Command.by_name('hello')

    >>> command = command_type()
    >>> command()
    'Hello, World!'

Just like with settings, for an interface implementation to take effect, the
module where the implementation is defined must be specified using ``rex_init``
parameter in ``setup.py``.

Error reporting
---------------

Use class ``Error`` or its subclasses for all custom exceptions.  The exception
constructor takes two arguments: ``message`` and ``payload``.  For example::

    >>> from rex.core import Error

    >>> raise Error("Found no product:", "beer")
    Traceback (most recent call last):
      ...
    Error: Found no product:
        beer

The error may contain multiple paragraphs::

    >>> product = "beer"
    >>> where = "refrigerator #%s" % 3
    >>> try:
    ...     raise Error("Found no product:", product)
    ... except Error as error:
    ...     error.wrap("While looking in:", where)
    ...     raise
    Traceback (most recent call last):
      ...
    Error: Found no product:
        beer
    While looking in:
        refrigerator #3

The same code could we written using ``guard`` context manager::

    >>> from rex.core import guard

    >>> with guard("While looking in:", where):
    ...     raise Error("Found no product:", product)
    Traceback (most recent call last):
      ...
    Error: Found no product:
        beer
    While looking in:
        refrigerator #3

Input validation
----------------

``rex.core`` contains utilities for validating and converting input values.
These utilities could be used for validating configuration settings, parsing
HTTP form parameters and so on.

For example, ``IntVal`` validates integer values::

    >>> from rex.core import IntVal

    >>> int_val = IntVal()
    >>> int_val(3)
    3
    >>> int_val('10')
    10

Note that the integer validator accepts both an integer object and a numeric
string converting the latter to an integer.

When the validator rejects the input value, ``Error`` exception is raised::

    >>> int_val('NaN')
    Traceback (most recent call last):
        ...
    Error: Expected an integer
    Got:
        'NaN'


API Reference
=============

Application
-----------

``rex.core.Rex(*requirements, **parameters)``
    Creates a Rex application.

    ``requirements``
        List of packages to include.  Each requirement is either a ``Package``
        object or a requirement specification in format understood by
        ``pkg_resources``.

    ``parameters``
        Application settings.

    ``on()``
        Activate the application.

        You can also use ``with`` statement on the application object to make
        the application active when the ``with`` block is executed.

    ``off()``
        Deactivate the application.

    ``__call__(environ, start_response)``
        WSGI interface.

``rex.core.get_rex()``
    Returns the current active Rex application.

Caching
-------

``rex.core.cached(fn)``
    This decorator caches the output of the wrapped function.  It ensures that
    for the given set of function arguments, the function is called no more
    than once.

Packages
--------

``rex.core.Package(name, modules, static)``
    Represents a package.

    ``name``
        The package name.

    ``modules``
        Set of modules containing extensions defined by the package.

    ``static``
        The directory which contains static files of the package.

    ``abspath(path)``
        Converts a relative path from the static directory to an absolute path.

    ``exists(path)``
        Checks if the package static directory contains the given file.

    ``open(path)``
        Opens a file in the package static directory.

    ``walk(path)``
        List files and directories in the package static directory.  The return
        value is the same as ``os.walk()``.

``rex.core.PackageCollection``
    Set of packages that form the application.

    ``modules``
        Set of modules that contain extensions defined by the application.

    ``iter(packages)``
        Iterates over packages in the collection.

    ``packages[name]``
        Gets a package by name.

    ``get(name, default=None)``
        Gets a package by name; returns ``default`` if not found.

    ``abspath(path)``, ``exists(path)``, etc
        The path must have the form::

            <package>:<local_path>

        These methods are delegated to the respective methods of
        the specified package.

``rex.core.get_packages()``
    Returns the collection of packages for the active application.

Extensions
----------

``rex.core.Extension``
    This class and its subclasses make the extension mechanism for Rex
    applications.

    ``sanitize()``
        This class method is called when a new subclass of ``Extension`` is
        created.  Override this method to provide validation for interface
        attributes and methods.

    ``enabled()``
        This class method is called to determine whether the extension is
        enabled.

    ``all()``
        This class method returns all implementations for the given interface.

    ``by_package(name)``
        This class method returns all implementations for the given interface
        defined in the given package.

Settings
--------

``rex.core.Setting``
    Interface for application configuration.

    ``name``
        Setting name.

    ``validate(value)``
        Called on a raw parameter value.  Must return a processed parameter
        value or raise an error.

    ``default`` or ``default()``
        Provides the setting value when it is not given explicitly.  If not
        set, the setting is mandatory.

``rex.core.SettingCollection``
    Collection of setting values.

``rex.core.get_settings()``
    Returns configuration of the active application.

WSGI
----

``rex.core.WSGI``
    This extension allows you to override the WSGI handler.

``get_wsgi()``
    Returns the WSGI handler.

Validators
----------

``rex.core.Validate()``
    Validates and sanitizes input value.

    This is an abstract class.  Subclasses must implement the ``__call__()``
    method.

``rex.core.AnyVal()``
    Accepts any input; returns it unchanged.

``rex.core.MaybeVal(validate)``
    Accepts ``None`` or delegates to the nested validator.

``rex.core.OneOfVal(*validates)``
    Accepts the value if at least one of the nested validators accepts
    the value.

``rex.core.StrVal(pattern=None)``
    Accepts a text value matching the given pattern.

``rex.core.ChoiceVal(*choices)``
    Accepts a text value among the given alternatives.

``rex.core.BoolVal()``
    Accepts a Boolean value.

``rex.core.IntVal(min_bound=None, max_bound=None)``
    Accepts an integer value.

``rex.core.UIntVal(max_bound=None)``
    Accepts a non-negative integer value.

``rex.core.PIntVal(max_bound=None)``
    Accepts a positive integer value.

``rex.core.SeqVal(validate_item=None)``
    Accepts a list of values matching ``validate_item``.

``rex.core.MapVal(validate_key=None, validate_item=None)``
    Accepts a dictionary with keys and items matching the given validators.

``rex.core.FileVal()``
    Accepts an existing file name.

``rex.core.DirectoryVal()``
    Accepts a directory name.

Errors
------

``rex.core.Error(message, payload=None)``
    The base exception for Rex applications.

    ``wrap(message, payload=None)``
        Adds a paragraph to the error report.

``guard(message, payload=None)``
    Use with ``with`` statement to automatically add a paragraph to all
    exceptions leaving the ``with`` block.


