*********************************************
  REX.WEB -- Web stack for the Rex platform
*********************************************

.. contents:: Table of Contents


Overview
========

This package provides a web stack for the Rex platform.

This package is a part of the RexDB platform for medical research data
management.  It is created by Prometheus Research, LLC and released under
AGPLv3 license.


Handlers and Routing
--------------------

Package ``rex.web`` provides an extensible web stack for Rex applications.
It includes:

* ability to write HTTP handlers in Python for specific URLs;
* server for package static files, which could be extended to provide
  custom renderers for specific file types;
* ability to customize error messages;
* templates (based on Jinja2);
* authentication and authorization mechanism.

``rex.web`` is build on top of the following packages:

* WebOb_ for HTTP request and response objects;
* Jinja2_ for templates;
* Beaker_ for sessions.

The following code fragment shows how a Rex application may respond to
a simple request::

    >>> from rex.core import Rex
    >>> demo = Rex('rex.web_demo')

    >>> from webob import Request
    >>> req = Request.blank('/')
    >>> print req.get_response(demo)
    200 OK
    Content-Type: text/html; charset=UTF-8
    Content-Length: 56
    <BLANKLINE>
    <!DOCTYPE html>
    <title>Welcome to REX.CORE_DEMO!</title>

The following diagram shows the structure of the web stack::

     o
     |
     |
     v
    ErrorCatcher -------------> HandleError
     |
     |
     v
    PackageRouter
     |
     |
     v
    StaticServer -------------> HandleFile
     |
     |
     v
    CommandDispatcher --------> HandleLocation, Command

``ErrorCatcher``
    Incoming HTTP requests are delegated to ``ErrorCatcher`` handler.
    It delegates it further down the stack.  If the downstream process
    produced an HTTP error, ``ErrorCatcher`` checks if the error code
    has a custom handler.  If so, the request is transferred to the
    error handler.

``PackageRouter``
    At this stage, it is determined which package will handle the request.
    The matches the incoming request with the mount table, which
    maps path prefixes to packages.

``StaticServer``
    This handler serves package static files from directory ``static/www``.
    The application may provide custom handlers for specific file types.
    If a file is not found, the request is passed to ``CommandDispatcher``.

``CommandDispatcher``
    The dispatcher looks for handlers for specific URLs written in Python.
    These handlers must be implementations of ``HandleLocation`` or
    ``Command`` extensions.

Location Handlers
-----------------

Implement ``HandleLocation`` to provide a handler for a specific URL.

For example, ``rex.web_demo`` implements a handler for URL ``/ping``::

    class HandlePing(HandleLocation):

        path = '/ping'

        def __call__(self, req):
            return Response(content_type='text/plain', body="PONG!")

The location is specified by attribute ``path`` and relative to the
package mount point.  Use ``'*'`` path to provide a catch-all handler.

::

    >>> req = Request.blank('/ping')
    >>> print req.get_response(demo)
    200 OK
    Content-Type: text/plain; charset=UTF-8
    Content-Length: 5
    <BLANKLINE>
    PONG!

File Handlers
-------------

By default, static files are served verbatim.  You can provide a
custom handler for specific file extensions by implementing ``HandleFile``
extension.

For example, ``rex.web_demo`` provides a custom handler for ``.sql`` files.
It assumes that the file contains a SQL query, executes the query and renders
the result in CSV::

    class HandleSQL(HandleFile):

        ext = '.sql'
        database = ':memory:'

        def __call__(self, req):
            packages = get_packages()
            sql_file = packages.open(self.filename)
            sql = sql_file.read()
            sql_file.close()

            conn = sqlite3.connect(self.database)
            cursor = conn.cursor()
            cursor.execute(sql)
            head = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            conn.close()

            response = Response(content_type='text/csv')
            response.content_disposition = "attachment; filename=%s.csv" \
                    % os.path.splitext(os.path.basename(self.filename))[0]

            writer = csv.writer(response.body_file, lineterminator='\n')
            writer.writerow(head)
            writer.writerows(rows)

            return response

Now assume that file ``rex.web_demo/static/www/two-plus-two.sql`` contains the
following query::

    SELECT
        2 AS "a",
        2 AS "b",
        2+2 AS "a+b";

Then the query ``/two-plus-two.sql`` will return::

    >>> req = Request.blank('/two-plus-two.sql')
    >>> print req.get_response(demo)
    200 OK
    Content-Type: text/csv; charset=UTF-8
    Content-Disposition: attachment; filename=two-plus-two.csv
    Content-Length: 14
    <BLANKLINE>
    a,b,a+b
    2,2,4
    <BLANKLINE>


Error Handlers
--------------

Implement ``HandleError`` extension to provide custom error handlers for
HTTP errors.

For example, ``rex.web_demo`` defines an error handler for ``404 Not Found``
errors::

    class HandleNotFound(HandleError):

        code = 404
        template = 'rex.web_demo:/templates/404.html'

        def __call__(self, req):
            return render_to_response(self.template, req, status=self.code,
                                      path=req.path)

Class attribute ``HandleError.code`` indicates which HTTP errors are handled
by this handler.  Use ``'*'`` code to provide a handler for all HTTP errors.

The error handler renders a template file
``rex.web_demo/static/templates/404.html``::

    <!DOCTYPE html>
    <html>
      <head><title>Page not found: {{ path|e }}</title></head>
      <body>The server cannot find the requested page!</body>
    </html>

Now you can try it::

    >>> req = Request.blank('/not-found')
    >>> print req.get_response(demo)
    404 Not Found
    Content-Type: text/html; charset=UTF-8
    Content-Length: 145
    <BLANKLINE>
    <!DOCTYPE html>
    <html>
      <head><title>Page not found: /not-found</title></head>
      <body>The server cannot find the requested page!</body>
    </html>

Authentication and Authorization
--------------------------------

``rex.web.authenticate(req)``
    Returns the current user or ``None``.

``rex.web.authorize(req, role)``
    Returns ``True`` if the current user has permissions to execute
    the action described by ``role``; returns ``False`` otherwise.

    FIXME: maybe, raise an exception?

``rex.web`` defines three roles:

``'authenticated'``
    Any logged in user.

``'anybody'``
    Everyone is allowed to do this.

``'nobody'``
    No one is allowed to do this.

Functions ``authenticate()`` and ``authorize()`` are implemented with
``Authenticate`` and ``Authorize`` extensions.


Static Files
------------

Files from ``static/www`` are exposed via HTTP.

Files and directories that start with ``.`` or ``_`` are hidden.

By default, static files are available for any authenticated user.  You can change
this using ``static/www/_roles.yaml``.  This file contains a mapping from file name
to role.  For example::

    index.html: anybody
    hidden.dat: nobody


Commands
--------

To implement a request handler in Python, you can implement ``HandleLocation``
interface directly.  However it is often convenient to inherit a handler from
``Command`` class, which provides support for authentication and parsing query
parameters.

The following command is implemented in ``rex.web_demo`` package::

    from rex.core import StrVal
    from rex.web import Command, Parameter
    from webob import Response

    class HelloCmd(Command):

        path = '/hello'
        role = 'anybody'
        parameters = [
            Parameter('name', StrVal('^[A-Za-z]+$'), default='World'),
        ]

        def render(self, req, name):
            return Response("Hello, %s!" % name, content_type='text/plain')

Here is how it could be executed::

    >>> req = Request.blank('/hello?name=Stranger')
    >>> print req.get_response(demo)
    200 OK
    Content-Type: text/plain; charset=UTF-8
    Content-Length: 16
    <BLANKLINE>
    Hello, Stranger!

Attribute ``Command.path`` specifies the URL handled by the command.

Attribute ``Command.role`` is the role required to peform the command.  Role
*anybody* allows anyone to perform the request.  If the attribute is not set,
*authenticated* role is assumed.

Attribute ``Command.parameters`` lists query parameters expected by the
command.  For each parameter, you specify its name, the format and the default
value.  If the default value is not provided, the parameter is mandatory.

Method ``Command.render()`` must be overridden in subclasses.  This method
takes the incoming HTTP request and parsed parameters and returns an HTTP
response.


API Reference
=============

Authentication and Authorization
--------------------------------

``rex.web.authenticate(req)``
    Returns the current user or ``None``.

``rex.web.authorize(req, role)``
    Returns whether the current user is allowed to performed an action
    described by ``role``.

``rex.web.Authenticate``
    This extension implements ``rex.web.authenticate()``.

``rex.web.Authorize``
    This extension implements ``rex.web.authorize()``.

``rex.core`` defines the following roles:

``authenticated``
    Any authenticated user can perform this action.

``anybody``
    This action has no restrictions.

``nobody``
    This action is forbidden.

Handlers, Commands, Mounting
----------------------------

The following extensions allows you to handle HTTP requests in Python code.
All handler types define method ``__call__(req)``, which must be overridden in
subclasses.

``rex.web.PathHandler()``
    Handles an HTTP request with a specific path.

    ``path``
        The path; ``'*'`` for catch-all.

``rex.web.FileHandler(filename)``
    Handles file requests.

    ``ext``
        File extensions, e.g. ``'.html'``.

``rex.web.ErrorHandler(error)``
    Handles HTTP errors.

    ``code``
        Error code, e.g. ``401``.

``rex.web.Command``
    Specialized variant of ``PathHandler`` with built-in permission checks
    and parameter parsing.

    Class attributes:

    ``path``
        The path handled by the command.
    ``role``
        The role which the current user must possess to execute the command.
        Use ``'anybody'`` to make a public command.  The default is
        ``'authenticated'``.
    ``parameters``
        List of command parameters.  Set to ``None`` to disable automatic
        argument parsing.

    Methods:

    ``render(req, **arguments)``
        Performs the command and returns an HTTP response.

``rex.web.Parameter(name, validate, default)``
    Describes command parameter.

``get_mount()``
    Returns the package mount table.  A mount table is a dictionary: the keys
    are package names, the values are path segments.

Templates
---------

``rex_jinja``
    Jinja2 environment object specialized to process files from ``static``
    directory.  Supports ``<package>:<static_path>`` syntax.

``render_to_response(path, req, **arguments)``
    Renders a template; returns a response.


.. _WebOb: http://docs.webob.org/
.. _Jinja2: http://jinja.pocoo.org/
.. _Beaker: http://beaker.readthedocs.org/

