/**
 * @copyright 2014-present, Prometheus Research, LLC
 * @flow
 */

import * as ReactForms from "react-forms";
import * as React from "react";
import PropTypes from "prop-types";
import * as ReactUI from "@prometheusresearch/react-ui-0.21";
import isArray from "lodash/isArray";
import isString from "lodash/isString";
import noop from "lodash/noop";

import { InjectI18N } from "rex-i18n";

import * as types from "../types.js";
import { isComplete } from "./Discrepancy";
import DiscrepancyList from "./DiscrepancyList";
import { fromDiscrepancies } from "./schema";
import { createReactFormsMessages } from "../instrument/validate";
import FormContext from "../form/FormContext";
import { resolveType } from "../instrument/schema.js";
import * as FormFormatConfig from "../form/FormFormatConfig.js";

function makeSolution(
  value: types.DiscrepancySet,
  instrument: types.RIOSInstrument,
  formatConfig: FormFormatConfig.Config,
) {
  // This get rids of all non-enumerable props
  let { ...values } = value;
  let { record, types: typesRegistry = {} } = instrument;

  function visit(values, record: types.RIOSField[], key: string[]) {
    let res = {};
    for (let name in values) {
      let field = record.find(f => f.id === name);
      let fieldKey = key.concat([name]);
      let value = values[name];

      if (value == null || field == null) {
        res[name] = value;
        continue;
      }

      let type = resolveType(field.type, typesRegistry);

      if (type.base === "recordList") {
        res[name] = {};
        let itemRecord = (type: any).record;
        value.forEach((item, idx) => {
          res[name][String(idx)] = visit(item, itemRecord, fieldKey);
        });
      } else if (type.base === "matrix") {
        res[name] = {};
        let colRecord = (type: any).columns;
        for (let row in value) {
          res[name][row] = visit(value[row], colRecord, fieldKey.concat([row]));
        }
      } else {
        let format = FormFormatConfig.findFieldConfig(formatConfig, fieldKey);
        res[name] = FormFormatConfig.parseValue(field, format, value);
      }
    }
    return res;
  }

  return visit(values, record, []);
}

type ReconcilerProps = {|
  /**
   * The RIOS Web Form Configuration to display.
   */
  form: types.RIOSForm,

  /**
   * The RIOS Instrument Definition that corresponds with the form.
   */
  instrument: types.RIOSInstrument,

  /**
   * The values for the custom/external variables used by the form.
   */
  parameters: Object,

  /**
   * The value discrepancies between the Entries (as generated by the
   * rex.instrument library).
   */
  discrepancies: types.DiscrepancySet,

  /**
   * Information about the Entries being reconciled.
   */
  entries: types.DiscrepancyEntry[],

  /**
   * The function to call when the user has made changes to their selections.
   * The callback will receive an object that contains:
   * * solution: The current state of the reconciled values that have been
   *   selected by the user so far.
   */
  onChange: Function,

  /**
   * The function to call when the user has completed reconciliation. The
   * callback will receive an object that contains:
   * * solution: The final reconciled values to apply as a solution to the
   *   discrepancies.
   */
  onComplete: Function,

  /**
   * A collection of API URLs that are used by various widgets or
   * functionality in the form.
   */
  apiUrls: Object,

  /**
   * Widget configuration.
   *
   * {
   *   edit: { [widgetType: string]: React.Component },
   *   view: { [widgetType: string]: React.Component },
   *   reconcile: { [widgetType: string]: React.Component },
   * }
   */
  widgetConfig: Object,
|};

type ReconcilerState = {|
  isComplete: boolean,
  formValue: types.FormValue,
|};

class Reconciler extends React.Component<ReconcilerProps, ReconcilerState> {
  getI18N: any;
  _: any;
  formatConfig: FormFormatConfig.Config;

  static defaultProps = {
    parameters: {},
    onComplete: noop,
    onChange: noop,
    apiUrls: {},
  };

  constructor(props, context) {
    super(props, context);
    let { discrepancies, instrument, form } = props;
    let i18n = this.getI18N();
    let messages = createReactFormsMessages({ i18n });
    let formatConfig = FormFormatConfig.make(form, i18n.config.locale);
    this.formatConfig = formatConfig;
    let schema = fromDiscrepancies(discrepancies, instrument, form, {
      i18n,
      formatConfig,
    });
    this.state = {
      formValue: ReactForms.createValue({
        schema,
        onChange: this.onChange,
        validate: (schema, value) => {
          return ReactForms.Schema.validate(schema, value, { messages });
        },
      }),
      isComplete: false,
    };
  }

  render() {
    let {
      form,
      parameters,
      discrepancies,
      entries,
      apiUrls,
      widgetConfig,
    } = this.props;
    let { formValue } = this.state;
    let showComplete = !this.state.isComplete;
    return (
      <FormContext
        self={this}
        widgetConfig={widgetConfig}
        form={form}
        parameters={parameters}
        events={null}
        apiUrls={apiUrls || {}}
      >
        <div>
          <DiscrepancyList entries={entries} formValue={formValue} />
          <ReactUI.Block textAlign="center">
            {showComplete && (
              <ReactUI.SuccessButton
                disabled={!isComplete(formValue, (discrepancies: any))}
                onClick={this.onComplete}
              >
                {this._("Complete Reconciliation")}
              </ReactUI.SuccessButton>
            )}
          </ReactUI.Block>
        </div>
      </FormContext>
    );
  }

  componentWillReceiveProps({ form, instrument, parameters, discrepancies }) {
    if (form !== this.props.form) {
      console.warn(
        // eslint-disable-line no-console
        '<Reconciler /> does not handle updating "form" prop',
      );
    }
    if (instrument !== this.props.instrument) {
      console.warn(
        // eslint-disable-line no-console
        '<Reconciler /> does not handle updating "instrument" prop',
      );
    }
    if (parameters !== this.props.parameters) {
      console.warn(
        // eslint-disable-line no-console
        '<Reconciler /> does not handle updating "parameters" prop',
      );
    }
    if (discrepancies !== this.props.discrepancies) {
      console.warn(
        // eslint-disable-line no-console
        '<Reconciler /> does not handle updating "discrepancies" prop',
      );
    }
  }

  onComplete = () => {
    this.setState(
      {
        isComplete: true,
      },
      () => {
        this.props.onComplete({
          solution: makeSolution(
            (this.state.formValue.value: any),
            this.props.instrument,
            this.formatConfig,
          ),
        });
      },
    );
  };

  onChange = formValue => {
    this.props.onChange({
      solution: makeSolution(
        formValue.value,
        this.props.instrument,
        this.formatConfig,
      ),
    });
    this.setState({ formValue });
  };
}

export default (InjectI18N(
  Reconciler,
): React.AbstractComponent<ReconcilerProps>);
