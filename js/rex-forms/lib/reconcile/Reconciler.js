/**
 * @copyright 2014-present, Prometheus Research, LLC
 */

import * as ReactForms from "react-forms";
import * as React from "react";
import PropTypes from 'prop-types';
import * as ReactUI from "@prometheusresearch/react-ui-0.21";
import isArray from "lodash/isArray";
import isString from "lodash/isString";
import noop from "lodash/noop";

import { InjectI18N } from "rex-i18n";

import { isComplete } from "./Discrepancy";
import DiscrepancyList from "./DiscrepancyList";
import { fromDiscrepancies } from "./schema";
import { createReactFormsMessages } from "../instrument/validate";
import FormContext from "../form/FormContext";

function makeSolution(value) {
  let { ...solution } = value;

  Object.keys(solution).forEach(key => {
    if (isArray(solution[key]) && !isString(solution[key][0])) {
      let mapped = {};
      solution[key].forEach((rec, idx) => {
        mapped[String(idx)] = rec;
      });
      solution[key] = mapped;
    }
  });

  return solution;
}

export default InjectI18N(
  class Reconciler extends React.Component {
    static propTypes = {
      /**
       * The RIOS Web Form Configuration to display.
       */
      form: PropTypes.object.isRequired,

      /**
       * The RIOS Instrument Definition that corresponds with the form.
       */
      instrument: PropTypes.object.isRequired,

      /**
       * The values for the custom/external variables used by the form.
       */
      parameters: PropTypes.object,

      /**
       * The value discrepancies between the Entries (as generated by the
       * rex.instrument library).
       */
      discrepancies: PropTypes.object.isRequired,

      /**
       * Information about the Entries being reconciled.
       */
      entries: PropTypes.array.isRequired,

      /**
       * The function to call when the user has made changes to their selections.
       * The callback will receive an object that contains:
       * * solution: The current state of the reconciled values that have been
       *   selected by the user so far.
       */
      onChange: PropTypes.func,

      /**
       * The function to call when the user has completed reconciliation. The
       * callback will receive an object that contains:
       * * solution: The final reconciled values to apply as a solution to the
       *   discrepancies.
       */
      onComplete: PropTypes.func,

      /**
       * A collection of API URLs that are used by various widgets or
       * functionality in the form.
       */
      apiUrls: PropTypes.object,

      /**
       * Widget configuration.
       *
       * {
       *   edit: { [widgetType: string]: React.Component },
       *   view: { [widgetType: string]: React.Component },
       *   reconcile: { [widgetType: string]: React.Component },
       * }
       */
      widgetConfig: PropTypes.object
    };

    static defaultProps = {
      parameters: {},
      onComplete: noop,
      onChange: noop,
      apiUrls: {}
    };

    constructor(props, context) {
      super(props, context);
      let { discrepancies, instrument, form } = props;
      let i18n = this.getI18N();
      let messages = createReactFormsMessages({ i18n });
      this.state = {
        formValue: ReactForms.createValue({
          schema: fromDiscrepancies(discrepancies, instrument, form, { i18n }),
          onChange: this.onChange,
          validate: (schema, value) => {
            return ReactForms.Schema.validate(schema, value, { messages });
          }
        }),
        isComplete: false
      };
    }

    render() {
      let {
        form,
        parameters,
        discrepancies,
        entries,
        apiUrls,
        widgetConfig
      } = this.props;
      let { formValue } = this.state;
      let showComplete = !this.state.isComplete;
      return (
        <FormContext
          self={this}
          widgetConfig={widgetConfig}
          form={form}
          parameters={parameters}
          events={null}
          apiUrls={apiUrls || {}}
        >
          <div>
            <DiscrepancyList entries={entries} formValue={formValue} />
            <ReactUI.Block textAlign="center">
              {showComplete && (
                <ReactUI.SuccessButton
                  disabled={!isComplete(formValue, discrepancies)}
                  onClick={this.onComplete}
                >
                  {this._("Complete Reconciliation")}
                </ReactUI.SuccessButton>
              )}
            </ReactUI.Block>
          </div>
        </FormContext>
      );
    }

    componentWillReceiveProps({ form, instrument, parameters, discrepancies }) {
      if (form !== this.props.form) {
        console.warn(
          // eslint-disable-line no-console
          '<Reconciler /> does not handle updating "form" prop'
        );
      }
      if (instrument !== this.props.instrument) {
        console.warn(
          // eslint-disable-line no-console
          '<Reconciler /> does not handle updating "instrument" prop'
        );
      }
      if (parameters !== this.props.parameters) {
        console.warn(
          // eslint-disable-line no-console
          '<Reconciler /> does not handle updating "parameters" prop'
        );
      }
      if (discrepancies !== this.props.discrepancies) {
        console.warn(
          // eslint-disable-line no-console
          '<Reconciler /> does not handle updating "discrepancies" prop'
        );
      }
    }

    onComplete = () => {
      this.setState(
        {
          isComplete: true
        },
        () => {
          this.props.onComplete({
            solution: makeSolution(this.state.formValue.value)
          });
        }
      );
    };

    onChange = formValue => {
      this.props.onChange({
        solution: makeSolution(formValue.value)
      });
      this.setState({ formValue });
    };
  }
);
